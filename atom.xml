<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joel&#39;s blog</title>
  
  <subtitle>Nice to meet you</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenjoel.github.io/"/>
  <updated>2023-02-01T13:52:57.331Z</updated>
  <id>http://shenjoel.github.io/</id>
  
  <author>
    <name>Joel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue.js资源</title>
    <link href="http://shenjoel.github.io/2017/02/17/Vue.js%E8%B5%84%E6%BA%90/"/>
    <id>http://shenjoel.github.io/2017/02/17/Vue.js资源/</id>
    <published>2017-02-17T10:55:00.000Z</published>
    <updated>2023-02-01T13:52:57.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js资源分享"><a href="#Vue-js资源分享" class="headerlink" title="Vue.js资源分享"></a>Vue.js资源分享</h2><h3 id="如何优雅地使用此文档"><a href="#如何优雅地使用此文档" class="headerlink" title="如何优雅地使用此文档"></a>如何优雅地使用此文档</h3><ol><li>入门先从官网文档入手，粗略过一遍有个印象，力求回查时能找到对应的关键字或位置。<ul><li><a href="http://cn.vuejs.org/">vuejs中文官网</a></li><li><a href="http://vuejs.org/">vuejs英文官网</a></li><li><a href="https://github.com/vuejs">vuejs组织</a></li></ul></li><li>发出一个问题之后，不要暂时的离开电脑，如果没有把握先不要提问。</li><li>珍惜每一次提问，感恩每一次反馈，每个人工作还是业余之外抽出的时间有限，充分准备好应有的资源之后再发问，有利于问题能够高效质量地得到解决。尤其是具备解决问题能力的人，通常时间都很宝贵。</li><li>先搜索，再思考，最后再提问，很多人把这个顺序搞反了。</li><li><ul><li><a href="https://www.zhihu.com/question/25464141">如何优雅地向前辈或者高手请教技术问题？</a><br>以上部分观点出自此文 <a href="http://www.zhihu.com/question/20824615">如何优雅地使用 Stack Overflow</a></li></ul></li></ol><h3 id="一-资源教程"><a href="#一-资源教程" class="headerlink" title="一. 资源教程"></a>一. 资源教程</h3><ol><li><p>综合类</p><ul><li><a href="https://github.com/vuejs/awesome-vue">vuejs 英文资料</a></li><li><a href="https://shimo.im/s/ab53739d-ca98-bd1e-aea0-fcc7378c6bb3">Vue中文资料总汇</a></li><li><a href="http://segmentfault.com/a/1190000000411057">Vue.js 的一些资源索引</a></li><li><a href="http://www.jianshu.com/p/afd8e1db7d9b">vue资料</a></li><li><a href="http://www.cnblogs.com/keepfool/p/5657065.html">Vue.js——vue-resource全攻略</a></li></ul></li><li><p>入门类</p><ul><li><a href="http://segmentfault.com/a/1190000003968020">vue 快速入门</a></li><li><a href="https://segmentfault.com/a/1190000005018970">vuex - 入门教程实例1</a></li><li><a href="https://segmentfault.com/a/1190000005148935">vuex - 入门教程实例2</a></li><li><a href="https://segmentfault.com/a/1190000006988584">vuex - 入门教程实例3</a></li></ul></li><li><p>英文教程</p><ul><li><a href="https://laracasts.com/series/learning-vue-step-by-step/">Learning Vue 1.0: Step By Step</a></li><li><a href="https://coligo.io/">vue Learning Tutorials</a></li></ul></li><li><p>社区</p><ul><li><a href="http://segmentfault.com/t/vue.js">sf - vue标签</a></li><li><a href="https://www.zhihu.com/topic/20022242/questions">知乎 - vue标签</a></li><li><a href="http://vue-js.com/">Vue.js专业中文社区</a></li><li><a href="https://github.com/vuejs/vue/issues">vue - issues</a></li></ul></li><li><p>视频教程</p><ul><li><a href="https://github.com/bhnddowinf/vuejs-learn">小凡哥录制视频教程</a></li></ul></li></ol><h3 id="二-文档"><a href="#二-文档" class="headerlink" title="二. 文档"></a>二. 文档</h3><ul><li>API<ul><li><a href="http://cn.vuejs.org/api/">Vue.js - API</a></li></ul></li><li><p>router</p><ul><li><a href="http://router.vuejs.org/zh-cn/index.html">vue-router文档</a></li></ul></li><li><p>表格</p><ul><li><a href="https://github.com/jinzhe/vue-editable">ZEE大神作品 - vue-editable</a></li></ul></li><li>分页<ul><li><a href="http://segmentfault.com/a/1190000003931500">vue入门－实现一个分页组件(1.0.3版本)</a></li><li><a href="https://github.com/cycgit/vue-pagination">vue(1.0.3) 分页组件</a></li><li><a href="https://www.npmjs.com/package/vue-pagination">分页组件 – 命令方式，支持多个，主要靠配置</a></li></ul></li><li>移动<ul><li><a href="https://github.com/vuejs/vue-touch">Hammer.js wrapper for Vue.js</a></li><li><a href="https://github.com/MeCKodo/vue-tap">vue的tap手势插件</a></li></ul></li><li>微信<ul><li><a href="http://aidenzou.github.io/vue-weui/">为微信Web服务量身设计</a></li></ul></li><li>日历<ul><li><a href="https://github.com/jinzhe/vue-calendar">ZEE大神作品 - vue-calendar</a></li><li><a href="https://github.com/hilongjw/vue-datepicker">Awe - 日历组件</a></li><li><a href="https://github.com/jas0ncn/vue-timepicker">jas0ncn - 日历组件</a></li></ul></li><li>进度条<ul><li><a href="https://github.com/greyby/vue-spinner">vue 进度条</a></li></ul></li><li>验证<ul><li><a href="https://github.com/vuejs/vue-validator">Validator component for VueJS</a></li><li><a href="https://github.com/xrado/vue-validator">form validator for vue 0.11</a></li></ul></li><li>Lazyload    <ul><li><a href="https://github.com/hilongjw/vue-lazyload">图片的lazyload</a></li><li><a href="https://github.com/ElemeFE/vue-loadmore">下拉加载</a></li></ul></li><li>Loader<ul><li><a href="http://segmentfault.com/a/1190000004060034">【vue】vue组件化开发初体验-示例vue-loader-example学习记录</a></li></ul></li><li>Uploader<ul><li><a href="https://www.npmjs.com/package/vue-file-upload">vue-file-upload</a></li><li><a href="https://www.npmjs.com/package/vue-file-upload-component">vue-file-upload-component</a></li></ul></li><li>Slide<ul><li><a href="https://github.com/guan6/vue-onlySlider-x">vue-onlySlider-x</a></li></ul></li><li>Drag<ul><li><a href="https://github.com/james2doyle/vue-drag-and-drop">vue-drag-and-drop</a></li></ul></li><li>二维码<ul><li><a href="https://github.com/xiaokaike/vue-qrcode">vue-qrcode</a></li></ul></li><li>省市联动<ul><li><a href="https://github.com/QingWei-Li/vue-region-picker">Vue 省市区三级联动组件</a></li></ul></li><li>TimeLine<ul><li><a href="https://github.com/yelingfeng/vue-timelinepick">Vue企业级时间轴选择器</a></li></ul></li><li>Template<ul><li><a href="https://github.com/yelingfeng/vue-ylf-template">vue2.0模板</a></li><li><a href="https://github.com/yelingfeng/vue-2.0-FamilyBucket">vue2.0全家桶实例</a></li></ul></li></ul><h3 id="四-示例"><a href="#四-示例" class="headerlink" title="四. 示例"></a>四. 示例</h3><ul><li>综合示例<ul><li><a href="http://cn-stage.vuejs.org/examples/">官方例子 - 包括Markdown编辑器，表格组件等</a>    </li><li><a href="https://github.com/vingojw/vue-vueRouter-webpack">Vue, vue-router, Webpack 和 vue-loader</a>    </li><li><a href="https://github.com/KennyWho/vue-chestnut">简单的vuejs例子 - 群内高手X-Roy大作</a>    </li><li><a href="https://github.com/toplan/vue-spa-example">vue single page app example</a>    </li><li><a href="http://segmentfault.com/a/1190000004372736">使用node+vue.js实现SPA应用</a>    </li></ul></li><li>Ajax<ul><li><a href="https://github.com/james2doyle/vue-ajax-form-component">A Vue.js component for creating simple AJAX forms.</a></li></ul></li><li>Webpack<ul><li><a href="http://jiongks.name/blog/just-vue/">Vue + webpack 项目实践</a></li><li><a href="http://segmentfault.com/a/1190000003630417">基于vue.js和webpack的Chat示例</a></li><li><a href="http://djyde.github.io/2015/08/29/vuejs-and-webpack-1/">Vue.js 和 Webpack（一）</a></li><li><a href="http://djyde.github.io/2015/08/30/vuejs-and-webpack-2/">Vue.js 和 Webpack（二）</a></li><li><a href="http://djyde.github.io/2015/08/31/vuejs-and-webpack-3/">Vue.js 和 Webpack（三）</a></li><li><a href="https://github.com/MeCKodo/webpack">二哲 - 结合具体项目的webpack配置</a></li></ul></li><li>Gulp<ul><li><a href="https://github.com/JsAaron/vue-gulp-webpack">vue-gulp-webpack单页面组件开发</a></li></ul></li><li>Tab<ul><li><a href="http://yuche.github.io/vue-strap/#tabs">vue tab</a></li></ul></li><li>Shopping<ul><li><a href="https://github.com/andylei18/vue-shopping">基于Vue模仿蘑菇街的单页应用</a></li></ul></li><li>其它<ul><li><a href="http://okoala.github.io/vue-antd/#!/docs/introduce">Ant Design 的 Vue 实现</a></li><li><a href="https://github.com/shinygang/Vue-cnodejs">基于vue.js重写Cnodejs.org社区的webapp</a></li><li><a href="https://github.com/giscafer/Ponitor">北京-giscafer - vue+webpack+node.js 价格监测应用</a></li></ul></li></ul><h3 id="五-开发工具相关"><a href="#五-开发工具相关" class="headerlink" title="五. 开发工具相关"></a>五. 开发工具相关</h3><ol><li>Atom<ul><li><a href="https://github.com/CYBAI/language-vue-component">atom vue 代码高亮</a></li><li><a href="http://www.jianshu.com/p/98f99c20493c">如何发布一个Atom的package</a></li><li><a href="https://atom.io/packages/vue-format">vue-format</a></li></ul></li><li>Sublime-text<ul><li><a href="https://github.com/vuejs/vue-syntax-highlight">Vue Syntax Highlight</a></li></ul></li><li>Webstorm<ul><li><a href="http://www.lred.me/2016/01/07/webstorm%E6%B7%BB%E5%8A%A0-vue%E6%96%87%E4%BB%B6%E6%94%AF%E6%8C%81/">webstorm添加*.vue文件支持</a>    </li><li><a href="https://plugins.jetbrains.com/plugin/8057?pr=webStorm">webstorm vue插件</a></li></ul></li></ol><h3 id="六-答疑"><a href="#六-答疑" class="headerlink" title="六. 答疑"></a>六. 答疑</h3><ul><li><a href="http://www.jianshu.com/p/7f7f050c9edf">Vue.js为什么不支持templateUrl模式</a></li><li><a href="https://github.com/jrainlau/vuejs-demo">实现了vuejs组件之间的通讯问题</a></li><li><a href="https://www.zhihu.com/question/38213423">国内有哪些公司在用Vue.js，有什么心得</a></li><li><a href="https://www.zhihu.com/question/39149401">vue 支持服务器端渲染吗</a></li><li><a href="http://div.io/topic/1343">Vue.js 和 Webpack</a></li></ul><h3 id="七-源码学习"><a href="#七-源码学习" class="headerlink" title="七. 源码学习"></a>七. 源码学习</h3><ul><li><a href="http://jiongks.name/blog/vue-code-review">Vue.js 源码学习笔记</a></li><li><a href="http://www.cnblogs.com/sskyy/p/3695003.html">VUE 源码分析</a></li><li><a href="http://segmentfault.com/a/1190000004384515">vue源码分析之如何实现observer和watcher</a></li><li><a href="https://segmentfault.com/a/1190000004670036">vue源码解析之一：transition</a></li><li><a href="https://github.com/JsAaron/vue-analysis">Vue源码学习 Vue.js v1.0.18</a></li></ul><h3 id="八-框架相关"><a href="#八-框架相关" class="headerlink" title="八. 框架相关"></a>八. 框架相关</h3><ul><li><a href="http://www.imooc.com/video/6346">尤小右 - 4-1 Vue.js-数据驱动的组件化前端开…</a></li><li><a href="https://simplecast.fm/s/5e60d9be">Evan You - Diving Deep into Vue.js</a></li></ul><blockquote><p>文章转自：<a href="https://github.com/jsfront/src/blob/master/vuejs.md">https://github.com/jsfront/src/blob/master/vuejs.md</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue-js资源分享&quot;&gt;&lt;a href=&quot;#Vue-js资源分享&quot; class=&quot;headerlink&quot; title=&quot;Vue.js资源分享&quot;&gt;&lt;/a&gt;Vue.js资源分享&lt;/h2&gt;&lt;h3 id=&quot;如何优雅地使用此文档&quot;&gt;&lt;a href=&quot;#如何优雅地使用此文档&quot;
      
    
    </summary>
    
    
      <category term="vue" scheme="http://shenjoel.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>初识OneSignal</title>
    <link href="http://shenjoel.github.io/2016/12/19/%E5%88%9D%E8%AF%86onesignal/"/>
    <id>http://shenjoel.github.io/2016/12/19/初识onesignal/</id>
    <published>2016-12-19T11:28:33.000Z</published>
    <updated>2023-02-02T10:44:18.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对于web-site的意义"><a href="#对于web-site的意义" class="headerlink" title="对于web site的意义"></a>对于web site的意义</h3><p>相信大家对于我们的手机锁屏界面上推送的消息都不陌生，尽管拿不到确切的数据证明用户的点击转化率有多高，但多一种通知的渠道，便能配合各种运营营销计划。但是，国内的大部分情况，消息推送的来源就是应用程序。对于web site来说，浏览过就是过了，即使对你的站点有那么一丝丝兴趣，当前无用，关了也就关了。俗话说得好，“不在沉默中爆发，便在沉默中灭亡”，那么就让OneSignal来爆发吧。 </p><h3 id="什么是OneSignal"><a href="#什么是OneSignal" class="headerlink" title="什么是OneSignal?"></a>什么是OneSignal?</h3><p><a href="https://onesignal.com/">OneSignal</a> 就是针对<code>网站和移动应用程序</code>的推送通知服务，为每个平台提供专用的SDK，RESTful服务器API和在线的运营后台，供营销人员设计和发送推送通知。</p><h3 id="为什么要使用OneSignal"><a href="#为什么要使用OneSignal" class="headerlink" title="为什么要使用OneSignal?"></a>为什么要使用OneSignal?</h3><p>– <code>使用简易</code>：实现到GCM / FCM（Google）和APNS（Apple）协议的可靠接口是很困难的。 有开源项目做到这一点，但即使最好的一个突破，当消息量一次超过50万。 这些协议也经常变化，例如，苹果最近发布了一个新的通知协议，并弃用他们旧的。<br>– <code>高级功能</code>：OneSignal提供营销工具，包括A / B测试，细分定位，本地化，点滴营销和转化跟踪。<br>– <code>多平台支持</code>：OneSignal提供统一的UI和API，以在iOS，Android，Amazon Fire，Windows Phone，Chrome应用，Safari，Chrome Web和Firefox上推送通知。<br>– <code>支持SDK</code>：OneSignal为几乎所有主要的跨平台移动开发环境提供SDK，包括Unity，PhoneGap，Cordova，Ionic，Intel XDK，React Native，Corona，Xamarin，Marmalade和Adobe Air。<br>– <code>免费开源</code>：最重要的是，OneSignal是一个免费服务，不限设备和通知。</p><p>参考文档:<a href="https://documentation.onesignal.com/docs">https://documentation.onesignal.com/docs</a></p><p><img src="//localhost:4000/img/webper.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对于web-site的意义&quot;&gt;&lt;a href=&quot;#对于web-site的意义&quot; class=&quot;headerlink&quot; title=&quot;对于web site的意义&quot;&gt;&lt;/a&gt;对于web site的意义&lt;/h3&gt;&lt;p&gt;相信大家对于我们的手机锁屏界面上推送的消息都不陌生，
      
    
    </summary>
    
    
      <category term="OneSignal" scheme="http://shenjoel.github.io/tags/OneSignal/"/>
    
      <category term="webpush" scheme="http://shenjoel.github.io/tags/webpush/"/>
    
  </entry>
  
  <entry>
    <title>javascript中0.1 + 0.2 != 0.3?</title>
    <link href="http://shenjoel.github.io/2016/11/20/javascript%E4%B8%AD0-1-0-2-0-3/"/>
    <id>http://shenjoel.github.io/2016/11/20/javascript中0-1-0-2-0-3/</id>
    <published>2016-11-20T11:32:55.000Z</published>
    <updated>2023-02-01T13:52:57.332Z</updated>
    
    <content type="html"><![CDATA[<p>0.1+0.2 等于0.3吗？相信拿着这条题目随便问一个高年级的小学生，他们都会毫不犹豫都回答：相等。是的，相等是正常的，这是常识。但是都说实践是检验真理的唯一标准，拿这道简单的算术题用javascript在chrome控制台试验一下：</p><p>结果令人大跌眼镜，<code>在控制台输入0.1+0.2 == 0.3返回的结果竟然是false</code>我们输入0.1+0.2，看看结果，竟然是<code>0.30000000000000004</code>。</p><p>这是为什么呢？在《Javascript权威指南》中有提到，<code>JS是不区分整数和浮点数的</code>，JS采用的是IEEE 754标准定义的64位浮点格式表示数字，所以JS中的所有数字都是浮点数。按照JS的数字格式，整数有的范围是<code>-2^53 ~ 2^53</code>，而且只能表示有限个浮点数，能表示的个数为<code>2^64 − 2^53 + 3</code>个。至于为什么是这个范围，可以具体看看《JavaScript 中的数字》这篇文章也解下。而我们都知道，浮点数的个数是无限的，这就导致了JS不能精确表达所有的浮点数，而只能是一个近似值。</p><p>那怎样才能比较<code>0.1+0.2 == 0.3</code>呢？既然浮点数是一个近似值，那我们可以认定在某个可以接受的精度范围内，他们是相等的。因此可以定义一个比较函数来比较浮点数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFloatEqual</span>(<span class="params">f1,f2,digits</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> f1.<span class="title function_">toFixed</span>(digits) === f2.<span class="title function_">toFixed</span>(digits);</span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">isFloatEqual</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">10</span>);   <span class="comment">//  返回true</span></span><br></pre></td></tr></table></figure></p><p>可以看到，这时再比较0.1+0.2就与0.3相等了。这种比较，其实是字符串的比较，toFixed方法，返回的是一个字符串。可以在控制台中输入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>)+<span class="number">0.2</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>你会发现，返回的结果是”0.10.2”</p><p>这种方法解决了0.1+0.2==0.3的问题，但是当我用isFloatEqual(0.3 - 0.2,0.1,10)的时候，发觉返回的值是false，这又是为什么呢？</p><p>原来0.3 - 0.2计算出来的是0.09999999999999998，上面的方法只能覆盖到计算结果比实际结果大的情况，而对于小的情况无能为力。</p><p>我们知道，当两个数相减，如果差在约定的精度范围内，我们就可以认为这两个数相等，根据这个原理，再来重写isFloatEqual函数，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFloatEqual</span>(<span class="params">f1,f2,digits</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(f1 - f2) &lt; digits;</span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">isFloatEqual</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.001</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isFloatEqual</span>(<span class="number">0.3</span>-<span class="number">0.2</span>,<span class="number">0.1</span>,<span class="number">0.001</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>那除了上面的方法外，能不能让JS在做加减法的时候精确一点呢？<br>我们知道，只要在-2^53 ~ 2^53的范围内，JS做整数的加减运算是精确的，那么我们是不是可以将浮点数转换为整数，再进行运算呢？按照这个思路，在《浅谈JavaScript浮点数及其运算》这篇文章中，提供了一种方法，将代码粘贴如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">accAdd</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> r1,r2,m;</span><br><span class="line"><span class="keyword">try</span>&#123;r1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;r2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">m=<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,<span class="title class_">Math</span>.<span class="title function_">max</span>(r1,r2))</span><br><span class="line"><span class="keyword">return</span> (arg1*m+arg2*m)/m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法是先计算出两个浮点数的小数位数n,两个参数再分别与10^n（放大倍数）相乘，以达到对两个参数取整的目的，再用整数来进行相加运算，加完后除掉放大的倍数就可以得出结果了。</p><p>现在用accAdd(0.1,0.2)，返回的结果是0.3了，但是评论里面马上有人提出accAdd(2.22,0.1) 的结果不是2.32，而是2.3200000000000003。原来在做arg1*m这一步时，依旧是浮点数运算，所以返回的结果不一定是整数，依旧是浮点数。</p><p>我看到作者在做减法的时候用了toFixed()，如果用toFixed(n)是不是就可以了呢？来试一下，函数改造成这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">accAdd</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> r1,r2,n,m;</span><br><span class="line"><span class="keyword">try</span>&#123;r1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;r2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">n = <span class="title class_">Math</span>.<span class="title function_">max</span>(r1,r2);</span><br><span class="line">m=<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,n);</span><br><span class="line"><span class="keyword">return</span> ((arg1*m+arg2*m)/m).<span class="title function_">toFixed</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这次再调用accAdd(2.22,0.1)时，返回的是2.32了，完美！</p><p>但是手贱试了下accAdd(2.22,0.08),返回的结果是2.30，而我期望返回的结果是2.3。上文已经提到过，toFixed返回的是一个字符串，所以用toFixed返回2.30看来是正常的了。那如果要返回2.3要怎样做呢？</p><p>其实很简单，用parseInt将arg1*m转换为整数就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">accAdd</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> r1,r2,m;</span><br><span class="line"><span class="keyword">try</span>&#123;r1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;r2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">m=<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,<span class="title class_">Math</span>.<span class="title function_">max</span>(r1,r2))</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">parseInt</span>(arg1*m,<span class="number">10</span>)+<span class="built_in">parseInt</span>(arg2*m,<span class="number">10</span>))/m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然并卵，这个计算依然是不准确的，有空再想想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;0.1+0.2 等于0.3吗？相信拿着这条题目随便问一个高年级的小学生，他们都会毫不犹豫都回答：相等。是的，相等是正常的，这是常识。但是都说实践是检验真理的唯一标准，拿这道简单的算术题用javascript在chrome控制台试验一下：&lt;/p&gt;
&lt;p&gt;结果令人大跌眼镜，&lt;c
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://shenjoel.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>总结使用node对接OAuth2的一些经验</title>
    <link href="http://shenjoel.github.io/2016/10/08/%E6%80%BB%E7%BB%93%E4%BD%BF%E7%94%A8node%E5%AF%B9%E6%8E%A5OAuth2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/"/>
    <id>http://shenjoel.github.io/2016/10/08/总结使用node对接OAuth2的一些经验/</id>
    <published>2016-10-08T08:52:06.000Z</published>
    <updated>2023-02-01T13:52:57.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、在服务器端的客户端证书验证，DEPTH-ZERO-SELF-SIGNED-CERT错误"><a href="#1、在服务器端的客户端证书验证，DEPTH-ZERO-SELF-SIGNED-CERT错误" class="headerlink" title="1、在服务器端的客户端证书验证，DEPTH_ZERO_SELF_SIGNED_CERT错误"></a>1、在服务器端的客户端证书验证，DEPTH_ZERO_SELF_SIGNED_CERT错误</h3><p>request模块中，rejectUnauthorized参数可设置忽略验证，开发调试方便，但生产环境下不可使用，正确方式是带上agentOptions: {ca: “xxx.pem”, …}<br>参考<a href="http://stackoverflow.com/questions/23601989/client-certificate-validation-on-server-side-depth-zero-self-signed-cert-error">stackoverflow</a></p><h3 id="2、发掘了两个不错的模块"><a href="#2、发掘了两个不错的模块" class="headerlink" title="2、发掘了两个不错的模块"></a>2、发掘了两个不错的模块</h3><ul><li><a href="https://github.com/ptarjan/node-cache">memory-cache</a><br>– A simple in-memory cache. put(), get() and del()<br>– 简单好用</li><li><a href="https://github.com/dylang/shortid">shortid</a><br>– ShortId creates amazingly short non-sequential url-friendly unique ids. Perfect for url shorteners, MongoDB and Redis ids, and any other id users might see.<br>– 功能强大</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、在服务器端的客户端证书验证，DEPTH-ZERO-SELF-SIGNED-CERT错误&quot;&gt;&lt;a href=&quot;#1、在服务器端的客户端证书验证，DEPTH-ZERO-SELF-SIGNED-CERT错误&quot; class=&quot;headerlink&quot; title=&quot;1、
      
    
    </summary>
    
    
      <category term="node" scheme="http://shenjoel.github.io/tags/node/"/>
    
      <category term="OAuth2" scheme="http://shenjoel.github.io/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>Error: DEPTH_ZERO_SELF_SIGNED_CERT</title>
    <link href="http://shenjoel.github.io/2016/09/20/Error-DEPTH-ZERO-SELF-SIGNED-CERT/"/>
    <id>http://shenjoel.github.io/2016/09/20/Error-DEPTH-ZERO-SELF-SIGNED-CERT/</id>
    <published>2016-09-20T03:16:31.000Z</published>
    <updated>2023-02-01T13:52:57.331Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在实现第三方系统对接时，提示了一个错误："><a href="#在实现第三方系统对接时，提示了一个错误：" class="headerlink" title="在实现第三方系统对接时，提示了一个错误："></a>在实现第三方系统对接时，提示了一个错误：</h4><pre><code>Error: DEPTH_ZERO_SELF_SIGNED_CERT</code></pre><h4 id="而在开发过程中跳过这一问题的方法是添加下面这句："><a href="#而在开发过程中跳过这一问题的方法是添加下面这句：" class="headerlink" title="而在开发过程中跳过这一问题的方法是添加下面这句："></a>而在开发过程中跳过这一问题的方法是添加下面这句：</h4><pre><code>process.env.NODE_TLS_REJECT_UNAUTHORIZED = &quot;0&quot;;</code></pre><h4 id="下文是一个中肯的解释："><a href="#下文是一个中肯的解释：" class="headerlink" title="下文是一个中肯的解释："></a>下文是一个中肯的解释：</h4><p>Node is complaining because the TLS (SSL) certificate it’s been given is self-signed (i.e. it has no parent - a depth of 0). It expects to find a certificate signed by another certificate that is installed in your OS as a trusted root.</p><p>Your “fix” is to disable Node from rejecting self-signed certificates by allowing ANY unauthorised certificate.</p><p>Your fix is insecure and shouldn’t really be done at all, but is often done in development (it should never be done in production).</p><p>The proper solution should be to put the self-signed certificate in your trusted root store OR to get a proper certificate signed by an existing Certificate Authority (which is already trusted by your server).</p><h4 id="大概意思是："><a href="#大概意思是：" class="headerlink" title="大概意思是："></a>大概意思是：</h4><p>Node被赋予了TLS（SSL）证书是自签名的，它希望找到由安装在您的操作系统作为一个受信任的根证书，另一个签名的证书。</p><p>你的“修复”是允许任何未经授权的证书，取消其拒绝自签名证书节点。这里指 <strong>process.env.NODE_TLS_REJECT_UNAUTHORIZED = “0”;</strong></p><p>你的解决方法是不安全的，应该不是真的都做到，但往往是在做开发（它不应该在生产中进行）。</p><p>正确的解决办法应该是把自签名证书在受信任的根存储或度日（这已经是你的服务器信任）现有的证书颁发机构签署一个适当的证书。</p><hr><p>此文章以记录自己还在坑里努力往上爬</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;在实现第三方系统对接时，提示了一个错误：&quot;&gt;&lt;a href=&quot;#在实现第三方系统对接时，提示了一个错误：&quot; class=&quot;headerlink&quot; title=&quot;在实现第三方系统对接时，提示了一个错误：&quot;&gt;&lt;/a&gt;在实现第三方系统对接时，提示了一个错误：&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
      <category term="node" scheme="http://shenjoel.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>探索pjax</title>
    <link href="http://shenjoel.github.io/2016/08/31/%E6%8E%A2%E7%B4%A2pjax/"/>
    <id>http://shenjoel.github.io/2016/08/31/探索pjax/</id>
    <published>2016-08-31T10:23:18.000Z</published>
    <updated>2023-02-01T13:52:57.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是pjax"><a href="#什么是pjax" class="headerlink" title="什么是pjax?"></a>什么是pjax?</h3><ul><li>它是一种浏览方式，当你点击一个站内的链接的时候， 不是做页面跳转， 而是站内页面刷新。 </li><li>它彻底改变标准网站的用户体验，多页面的呈现，单页面的操作</li></ul><h3 id="为什么要用pjax？"><a href="#为什么要用pjax？" class="headerlink" title="为什么要用pjax？"></a>为什么要用pjax？</h3><p>web研发模式演变的两种状态：</p><ul><li>以后端为主的MVC开发模式<br>– 前后端耦合程度高，后端控制MV层，沟通成本大，但利于SEO</li><li>Ajax为主的SPA型开发模式<br>– SPA - Single Page Application 指单页面应用，通过带”#”的链接，获取其hash值在同一个页面更新不同的场景，达到浏览器级别的前进与后退；而这种开发模式，前后端是通过ajax交换数据，所以爬虫爬下来的页面都是空白，虽然拥有良好的用户体验，但不利于SEO</li></ul><p>有没有那么一种解决方案，即能做SEO，又能得到像SPA一样的用户体验呢？</p><p>是的，pjax是一个优秀的解决方案，你有足够多的理由来使用它：</p><ul><li>可以在页面切换间平滑过渡，增加Loading动画。</li><li>可以在各个页面间传递数据，不依赖URL。</li><li>可以选择性的保留状态，如音乐网站，切换页面时不会停止播放歌曲。</li><li>所有的标签都可以用来跳转，不仅仅是a标签。</li><li>避免了公共JS的反复执行，如无需在各个页面打开时都判断是否登录过等等。</li><li>减少了请求体积，节省流量，加快页面响应速度。</li><li>平滑降级到低版本浏览器上，对SEO也不会有影响。</li></ul><h3 id="pjax的原理"><a href="#pjax的原理" class="headerlink" title="pjax的原理"></a>pjax的原理</h3><p>第一步：拦截a标签的默认跳转动作。<br>第二步：使用Ajax请求新页面。<br>第三步：将返回的Html替换到页面中。<br>第四步：使用HTML5的History API或者Url的Hash修改Url。</p><h3 id="HTML5-History-API"><a href="#HTML5-History-API" class="headerlink" title="HTML5 History API"></a>HTML5 History API</h3><p><strong>history.pushState(state, title, url)</strong><br>pushState方法会将当前的url添加到历史记录中，然后修改当前url为新url。请注意，这个方法只会修改地址栏的Url显示，但并不会发出任何请求。我们正是基于此特性来实现Pjax。它有3个参数：</p><ul><li>state: 用以存储关于你所要插入到历史记录的条目的相关信息。</li><li>title: 顾名思义，就是document.title。不过这个参数目前并无作用，浏览器目前会选择忽略它。</li><li>url: 新url，也就是你要显示在地址栏上的url。</li></ul><p><strong>history.replaceState(state, title, url)</strong><br>replaceState方法与pushState大同小异，区别只在于pushState会将当前url添加到历史记录，之后再修改url，而replaceState只是修改url，不添加历史记录。</p><p><strong>window.onpopstate 事件</strong><br>一般来说，每当url变动时，popstate事件都会被触发。但若是调用pushState来修改url，该事件则不会触发，因此，我们可以把它用作浏览器的前进后退事件。该事件有一个参数，就是上文pushState方法的第一个参数state。</p><h3 id="不支持HTML5-PushState的浏览器怎么办？"><a href="#不支持HTML5-PushState的浏览器怎么办？" class="headerlink" title="不支持HTML5 PushState的浏览器怎么办？"></a>不支持HTML5 PushState的浏览器怎么办？</h3><p>IE6到IE9是不支持pushState的，要修改Url，只能利用Url的Hash，也即是#号。</p><p>你可以随意找个网站试一下，在url后面加上#号和任意内容，页面并不会刷新。此时点击后退也只会回到上一条#号，同样不会刷新。</p><p>那么我们只需把pushState(新url)换成location.hash = 新url，把onpopstate事件换成onhashchange事件就可以兼容IE了。<br>QQ音乐，网易云音乐等就是使用这种方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是pjax&quot;&gt;&lt;a href=&quot;#什么是pjax&quot; class=&quot;headerlink&quot; title=&quot;什么是pjax?&quot;&gt;&lt;/a&gt;什么是pjax?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;它是一种浏览方式，当你点击一个站内的链接的时候， 不是做页面跳转， 而是站内页面刷新
      
    
    </summary>
    
    
      <category term="pjax" scheme="http://shenjoel.github.io/tags/pjax/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-尾递归优化</title>
    <link href="http://shenjoel.github.io/2016/08/26/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/"/>
    <id>http://shenjoel.github.io/2016/08/26/ES6学习笔记-尾递归优化/</id>
    <published>2016-08-26T08:12:18.000Z</published>
    <updated>2023-02-01T13:52:57.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果<a href="/2016/08/26/ES6学习笔记-尾调用优化/">尾调用</a>自身，就称为<strong>尾递归</strong>。</p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="title function_">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><br>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p><p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><br>还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</p><p>如果是非尾递归的fibonacci 递归方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fibonacci</span> (n) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>) + <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Fibonacci</span>(<span class="number">10</span>); <span class="comment">// 89</span></span><br><span class="line"><span class="comment">// Fibonacci(100)</span></span><br><span class="line"><span class="comment">// Fibonacci(500)</span></span><br><span class="line"><span class="comment">// 堆栈溢出了</span></span><br></pre></td></tr></table></figure><br>如果我们使用尾递归优化过的fibonacci 递归算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fibonacci2</span> (n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Fibonacci2</span> (n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Fibonacci2</span>(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br><span class="line"><span class="title class_">Fibonacci2</span>(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span></span><br><span class="line"><span class="title class_">Fibonacci2</span>(<span class="number">10000</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p><hr><h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p><p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tailFactorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><br>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。</p><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn, n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tailFactorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> factorial = <span class="title function_">currying</span>(tailFactorial, <span class="number">1</span>);</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><br>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</p><p>第二种方法就简单多了，就是采用ES6的函数默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><br>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p><p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p><hr><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li><strong>func.arguments</strong>：返回调用时函数的参数。</li><li><strong>func.caller</strong>：返回调用当前函数的那个函数。</li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">restricted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  restricted.<span class="property">caller</span>;    <span class="comment">// 报错</span></span><br><span class="line">  restricted.<span class="property">arguments</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">restricted</span>();</span><br></pre></td></tr></table></figure></p><hr><h3 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h3><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p><p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sum</span>(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure><br>上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归100000次，就会报错，提示超出调用栈的最大次数。</p><p>蹦床函数（trampoline）可以将递归执行转为循环执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trampoline</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">    f = <span class="title function_">f</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p><p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum.<span class="title function_">bind</span>(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中，<strong>sum</strong>函数的每次执行，都会返回自身的另一个版本。</p><p>现在，使用蹦床函数执行<strong>sum</strong>，就不会发生调用栈溢出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">trampoline</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><br>蹦床函数并不是真正的尾递归优化，下面的实现才是。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tco</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">accumulator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    accumulated.<span class="title function_">push</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.<span class="property">length</span>) &#123;</span><br><span class="line">        value = f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, accumulated.<span class="title function_">shift</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="title function_">tco</span>(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sum</span>(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><br>上面代码中，<strong>tco</strong>函数是尾递归优化的实现，它的奥妙就在于状态变量<strong>active</strong>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<strong>sum</strong>返回的都是<strong>undefined</strong>，所以就避免了递归执行；而<strong>accumulated</strong>数组存放每一轮<strong>sum</strong>执行的参数，总是有值的，这就保证了<strong>accumulator</strong>函数内部的<strong>while</strong>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;尾递归&quot;&gt;&lt;a href=&quot;#尾递归&quot; class=&quot;headerlink&quot; title=&quot;尾递归&quot;&gt;&lt;/a&gt;尾递归&lt;/h3&gt;&lt;p&gt;函数调用自身，称为递归。如果&lt;a href=&quot;/2016/08/26/ES6学习笔记-尾调用优化/&quot;&gt;尾调用&lt;/a&gt;自身，就称为&lt;s
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://shenjoel.github.io/tags/ES6/"/>
    
      <category term="javascript" scheme="http://shenjoel.github.io/tags/javascript/"/>
    
      <category term="优化" scheme="http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-尾调用优化</title>
    <link href="http://shenjoel.github.io/2016/08/26/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://shenjoel.github.io/2016/08/26/ES6学习笔记-尾调用优化/</id>
    <published>2016-08-26T07:24:56.000Z</published>
    <updated>2023-02-01T13:52:57.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a><strong>什么是尾调用？</strong></h3><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。<br>以下三种情况，都不属于尾调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="title function_">g</span>(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="title function_">g</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="title function_">g</span>(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">m</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">n</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p><hr><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a><strong>尾调用优化</strong></h3><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(m + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">g</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><br>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p><p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addOne</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params">b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">inner</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是尾调用？&quot;&gt;&lt;a href=&quot;#什么是尾调用？&quot; class=&quot;headerlink&quot; title=&quot;什么是尾调用？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是尾调用？&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://shenjoel.github.io/tags/ES6/"/>
    
      <category term="javascript" scheme="http://shenjoel.github.io/tags/javascript/"/>
    
      <category term="优化" scheme="http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-数组的空位</title>
    <link href="http://shenjoel.github.io/2016/08/24/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D/"/>
    <id>http://shenjoel.github.io/2016/08/24/ES6学习笔记-数组的空位/</id>
    <published>2016-08-24T09:42:15.000Z</published>
    <updated>2023-02-01T13:52:57.330Z</updated>
    
    <content type="html"><![CDATA[<p>数组的空位指，数组的某一个位置没有任何值。比如，<strong>Array</strong>构造函数返回的数组都是空位。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure><br>上面代码中，Array(3)返回一个具有3个空位的数组。</p><p>注意，空位不是<strong>undefined</strong>，一个位置的值等于<strong>undefined</strong>，依然是有值的。空位是没有任何值，in运算符可以说明这一点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p><ul><li>forEach(), filter(), every() 和some()都会跳过空位。</li><li>map()会跳过空位，但会保留这个值</li><li>join()和toString()会将空位视为<strong>undefined</strong>，而<strong>undefined</strong>和<strong>null</strong>会被处理成空字符串。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i)); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">some</span>(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// map方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"><span class="comment">// join方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].<span class="title function_">join</span>(<span class="string">&#x27;#&#x27;</span>) <span class="comment">// &quot;#a##&quot;</span></span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].<span class="title function_">toString</span>() <span class="comment">// &quot;,a,,&quot;</span></span><br></pre></td></tr></table></figure><p>ES6则是明确将空位转为<strong>undefined</strong>。</p><p><strong>Array.from</strong>方法会将数组的空位，转为<strong>undefined</strong>，也就是说，这个方法不会忽略空位。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure><br>扩展运算符（<strong>…</strong>）也会将空位转为<strong>undefined</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line"><span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure><br><strong>copyWithin()</strong>会连空位一起拷贝。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line"><span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure><br><strong>fill()</strong>会将空位视为正常的数组位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure><br><strong>for…of</strong>循环也会遍历空位。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><br>上面代码中，数组arr有两个空位，<strong>for…of</strong>并没有忽略它们。如果改成map方法遍历，空位是会跳过的。</p><p><strong>entries()</strong>、<strong>keys()</strong>、<strong>values()</strong>、<strong>find()</strong>和<strong>findIndex()</strong>会将空位处理成<strong>undefined</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">entries</span>()] <span class="comment">// [[0,undefined], [1,&quot;a&quot;]]</span></span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">keys</span>()] <span class="comment">// [0,1]</span></span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">values</span>()] <span class="comment">// [undefined,&quot;a&quot;]</span></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">find</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">findIndex</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><br>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组的空位指，数组的某一个位置没有任何值。比如，&lt;strong&gt;Array&lt;/strong&gt;构造函数返回的数组都是空位。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://shenjoel.github.io/tags/ES6/"/>
    
      <category term="javascript" scheme="http://shenjoel.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>移动web性能优化篇-图片的加载</title>
    <link href="http://shenjoel.github.io/2016/08/20/%E7%A7%BB%E5%8A%A8web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87-%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://shenjoel.github.io/2016/08/20/移动web性能优化篇-图片的加载/</id>
    <published>2016-08-20T09:55:40.000Z</published>
    <updated>2023-02-01T13:52:57.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="控制图片加载"><a href="#控制图片加载" class="headerlink" title="控制图片加载"></a>控制图片加载</h3><p>在移动浏览器打开网页，经常能感觉到明显的卡顿。造成卡顿的原因除了页面 DOM 结构复杂、CSS 过多地触发 Layout/Paint/Composite、存在复杂 JS 逻辑等等，也可能是没有控制图片的加载时机。</p><p>通常浏览器会并发加载 6 个同域名图片，如果做了域名散列，那很可能在打开页面后的短短几秒内，几十个图片都在加载。这些连接带来的 TCP、带宽、CPU、内存等开销，很容易让页面卡顿。所以在移动端，我们要让图片加载变得可控。</p><ul><li><strong> 按需加载图片。 </strong>在 PC 端，我们基本都会做图片 Lazy Load，这个优化策略在移动端同样适用。由于移动端性能有限、带宽昂贵，Lazy Load 更为重要。实际上不光是图片可以做 Lazy Load，页面所有资源包括 DOM 节点都应该做成按需加载。通常在移动端，我们只加载页面可视区域及其下方一定距离内的资源。</li><li><strong> 顺序加载图片。 </strong>在 PC 端，由于硬件性能和带宽足够，并行加载更多的图片通常是最好的选择。而在移动端，人为控制图片加载顺序，例如使其从上到下、从左到右逐个加载，有时可以带来更好的体验。</li><li><strong> 不要在页面滚定时加载图片。 </strong>按需加载图片逻辑需要监听页面滚动事件，根据页面当前可视区域决定加载哪些图片。在移动端滚动页面本来就很耗费性能，如果这时候还要加载图片，非常容易造成页面卡顿。在页面滚定停止之后才开始载入图片，能有效减少这种卡顿。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;控制图片加载&quot;&gt;&lt;a href=&quot;#控制图片加载&quot; class=&quot;headerlink&quot; title=&quot;控制图片加载&quot;&gt;&lt;/a&gt;控制图片加载&lt;/h3&gt;&lt;p&gt;在移动浏览器打开网页，经常能感觉到明显的卡顿。造成卡顿的原因除了页面 DOM 结构复杂、CSS 过多地触发 
      
    
    </summary>
    
    
      <category term="优化" scheme="http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="移动WEB" scheme="http://shenjoel.github.io/tags/%E7%A7%BB%E5%8A%A8WEB/"/>
    
      <category term="图片" scheme="http://shenjoel.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>移动web性能优化篇-图片的大小</title>
    <link href="http://shenjoel.github.io/2016/08/20/%E7%A7%BB%E5%8A%A8web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87-%E5%9B%BE%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F/"/>
    <id>http://shenjoel.github.io/2016/08/20/移动web性能优化篇-图片的大小/</id>
    <published>2016-08-20T09:40:50.000Z</published>
    <updated>2023-02-01T13:52:57.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="控制图片大小"><a href="#控制图片大小" class="headerlink" title="控制图片大小"></a>控制图片大小</h3><p>图片高宽越大，意味着需要越多的网络开销。常见图片格式都经过了高度压缩，尺寸越大的图片还意味着浏览器在解码过程中需要耗费更多 CPU，解码之后的位图需要占用更多内存。在移动端，我们更应该关注图片大小。</p><ul><li><strong> 根据 DPR（window.devicePixelRatio，设备像素比）选择合适的图片尺寸。 </strong>现在的手机基本上都是高清屏，如果一味追求让图片更小而使用单倍图也不现实。这一点上，最佳实践是根据产品特性，结合用户 DPR 分布情况来选择合适的尺寸。例如在我们某个产品中：图片加载速度比图片质量更重要；用户 DPR 分布前三是：2、3、1.5。我们最终使用了 1.5 倍图，并且在图床缩放图片时，加了一点点锐化效果。最终图片体积很小，质量也尚可接受。</li><li><strong> 处理好响应式图片（Responsive Image）。 </strong>移动上很多图片宽度不是固定像素值，例如通栏 Banner 图片的宽度是跟着设备走的。对于这种场景，使用 JS 获取设备宽度，拼出最适合当前设备的图片尺寸，交给图床进行缩放，无疑能在图片体积和质量上找到最佳平衡点。但这种做法并不可取，移动设备宽度各式各样，如果裁图规格太多，容易降低 CDN 缓存命中率。图床实时处理完图片再分发到 CDN 更耗时，在移动端让图片命中 CDN 缓存也很重要。处理响应式图片的最佳实践是根据用户屏幕尺寸分布，制定出几档裁图规则，页面根据用户设备宽度使用最合适的档位，并对重要的图片（例如头部焦点图）提前预热 CDN。</li><li><strong> 使用 WEBP 格式。 </strong>有一种减少图片体积的灵丹妙药 —— 使用压缩比例更高的 WEBP 格式。《<a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">移动端图片格式调研</a>》这篇文章详细地对比了各种移动端图片格式及各自适用场景。对于 WEBP 的最佳实践是只要浏览器支持就用，虽然 WEBP 解码慢于 JPG，但在同等图片质量下，WEBP 体积通常比 JPG 小很多。</li></ul><p>要判断浏览器是否支持 WEBP，可以检查 HTTP 请求头部字段 <code>Accept</code> 的值是否包含 webp。例如这是 Chrome 给图片请求加的 <code>Accept</code>：</p><blockquote><p>Accept: image/webp,image/<em>,</em>/*;q=0.8</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;控制图片大小&quot;&gt;&lt;a href=&quot;#控制图片大小&quot; class=&quot;headerlink&quot; title=&quot;控制图片大小&quot;&gt;&lt;/a&gt;控制图片大小&lt;/h3&gt;&lt;p&gt;图片高宽越大，意味着需要越多的网络开销。常见图片格式都经过了高度压缩，尺寸越大的图片还意味着浏览器在解码过程
      
    
    </summary>
    
    
      <category term="优化" scheme="http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="移动WEB" scheme="http://shenjoel.github.io/tags/%E7%A7%BB%E5%8A%A8WEB/"/>
    
      <category term="图片" scheme="http://shenjoel.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>移动web性能优化篇-图片的影响</title>
    <link href="http://shenjoel.github.io/2016/08/20/%E7%A7%BB%E5%8A%A8web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87-%E5%9B%BE%E7%89%87%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>http://shenjoel.github.io/2016/08/20/移动web性能优化篇-图片的影响/</id>
    <published>2016-08-20T08:27:25.000Z</published>
    <updated>2023-02-01T13:52:57.333Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讨论在移动 WEB 中，图片的加载给页面整体性能带来的影响以及优化策略。</p><p>我们知道，浏览器的 DOMContentLoaded 事件会在主页面加载并解析完成之后触发，不会等页面样式、图片、iframe 等子资源加载完。以下是 <a href="https://developer.mozilla.org/en/docs/Web/Events/DOMContentLoaded">MDN</a> 对它的描述：</p><blockquote><p>The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.</p></blockquote><p>但在实际测试中，移动端完全相同的页面，加载与不加载图片对 DOMContentLoaded 触发时机的影响却很大。以下是我们在某个移动产品中，将图片延迟加载后的 DOMContentLoaded 时间对比，可以看出明显变化：<br><img src="//st.imququ.com/i/webp/static/uploads/2015/10/dom-ready-time.png" alt=""></p><p>我们只是将页面所有图片（大约十几张）进行延迟加载，就让 DOMContentLoaded 事件提前 250 毫秒触发。这是我之前没有意料到的，移动设备在网络、CPU、内存等方面的性能与 PC 相比差距很大，很多 PC 上可以忽略的问题，在移动端必须重视起来。</p><p>移动 WEB 要做好图片优化，无外乎两点：</p><ul><li><a href="/2016/08/20/移动web性能优化篇-图片的大小/">控制图片大小</a></li><li><a href="/2016/08/20/移动web性能优化篇-图片的加载/">控制图片加载</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讨论在移动 WEB 中，图片的加载给页面整体性能带来的影响以及优化策略。&lt;/p&gt;
&lt;p&gt;我们知道，浏览器的 DOMContentLoaded 事件会在主页面加载并解析完成之后触发，不会等页面样式、图片、iframe 等子资源加载完。以下是 &lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="优化" scheme="http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="移动WEB" scheme="http://shenjoel.github.io/tags/%E7%A7%BB%E5%8A%A8WEB/"/>
    
      <category term="图片" scheme="http://shenjoel.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>在hexo中加入多说评论模块</title>
    <link href="http://shenjoel.github.io/2016/08/19/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA/"/>
    <id>http://shenjoel.github.io/2016/08/19/在hexo中加入多说评论/</id>
    <published>2016-08-19T07:51:58.000Z</published>
    <updated>2023-02-01T13:52:57.332Z</updated>
    
    <content type="html"><![CDATA[<p>首先在根目录下_config.yml中增加duoshuo_shortname: 你站点的short_name，这里的short_name也就是你的二级域名, 例如(<a href="http://shenjoel.github.io/)。">http://shenjoel.github.io/)。</a><br>如果使用的是默认的landscape主题只需要修改themes\landscape\layout_partial\article.ejs中的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class="line">&lt;section <span class="built_in">id</span>=<span class="string">&quot;comments&quot;</span>&gt;</span><br><span class="line">&lt;div <span class="built_in">id</span>=<span class="string">&quot;disqus_thread&quot;</span>&gt;</span><br><span class="line"> &lt;noscript&gt;Please <span class="built_in">enable</span> JavaScript to view the &lt;a href=<span class="string">&quot;//disqus.com/?ref_noscript&quot;</span>&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; page.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;</span><br><span class="line">&lt;section <span class="built_in">id</span>=<span class="string">&quot;comments&quot;</span>&gt;</span><br><span class="line">&lt;!-- 多说评论框 start --&gt;</span><br><span class="line">&lt;div <span class="built_in">id</span>=<span class="string">&quot;ds-thread&quot;</span> class=<span class="string">&quot;ds-thread&quot;</span> data-thread-key=<span class="string">&quot;&lt;%= page.path %&gt;&quot;</span> data-title=<span class="string">&quot;&lt;%= page.title %&gt;&quot;</span> data-url=<span class="string">&quot;&lt;%= page.permalink %&gt;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 多说评论框 end --&gt;</span><br><span class="line">&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">var duoshuoQuery = &#123;short_name:<span class="string">&quot;datoublog&quot;</span>&#125;;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">var ds = document.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">ds.type = <span class="string">&#x27;text/javascript&#x27;</span>;ds.async = <span class="literal">true</span>;</span><br><span class="line">ds.src = (document.location.protocol == <span class="string">&#x27;https:&#x27;</span> ? <span class="string">&#x27;https:&#x27;</span> : <span class="string">&#x27;http:&#x27;</span>) + <span class="string">&#x27;//static.duoshuo.com/embed.js&#x27;</span>;</span><br><span class="line">ds.charset = <span class="string">&#x27;UTF-8&#x27;</span>;</span><br><span class="line">(document.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[0] </span><br><span class="line"> || document.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[0]).appendChild(ds);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- 多说公共JS代码 end --&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在根目录下_config.yml中增加duoshuo_shortname: 你站点的short_name，这里的short_name也就是你的二级域名, 例如(&lt;a href=&quot;http://shenjoel.github.io/)。&quot;&gt;http://shenjoel.
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://shenjoel.github.io/tags/hexo/"/>
    
      <category term="多说" scheme="http://shenjoel.github.io/tags/%E5%A4%9A%E8%AF%B4/"/>
    
      <category term="评论" scheme="http://shenjoel.github.io/tags/%E8%AF%84%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://shenjoel.github.io/2016/08/19/hello-world/"/>
    <id>http://shenjoel.github.io/2016/08/19/hello-world/</id>
    <published>2016-08-19T07:51:58.000Z</published>
    <updated>2023-02-01T13:52:57.331Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code>$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code>$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code>$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code>$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://shenjoel.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
