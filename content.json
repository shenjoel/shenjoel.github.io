{"meta":{"title":"Joel's blog","subtitle":"Nice to meet you","description":"前端开发&深入浅出","author":"Joel","url":"http://shenjoel.github.io"},"pages":[{"title":"tags","date":"2016-08-19T14:33:13.000Z","updated":"2023-02-01T13:52:57.333Z","comments":false,"path":"tags/index.html","permalink":"http://shenjoel.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue.js资源","slug":"Vue.js资源","date":"2017-02-17T10:55:00.000Z","updated":"2023-02-01T13:52:57.331Z","comments":true,"path":"2017/02/17/Vue.js资源/","link":"","permalink":"http://shenjoel.github.io/2017/02/17/Vue.js%E8%B5%84%E6%BA%90/","excerpt":"","text":"Vue.js资源分享如何优雅地使用此文档 入门先从官网文档入手，粗略过一遍有个印象，力求回查时能找到对应的关键字或位置。 vuejs中文官网 vuejs英文官网 vuejs组织 发出一个问题之后，不要暂时的离开电脑，如果没有把握先不要提问。 珍惜每一次提问，感恩每一次反馈，每个人工作还是业余之外抽出的时间有限，充分准备好应有的资源之后再发问，有利于问题能够高效质量地得到解决。尤其是具备解决问题能力的人，通常时间都很宝贵。 先搜索，再思考，最后再提问，很多人把这个顺序搞反了。 如何优雅地向前辈或者高手请教技术问题？以上部分观点出自此文 如何优雅地使用 Stack Overflow 一. 资源教程 综合类 vuejs 英文资料 Vue中文资料总汇 Vue.js 的一些资源索引 vue资料 Vue.js——vue-resource全攻略 入门类 vue 快速入门 vuex - 入门教程实例1 vuex - 入门教程实例2 vuex - 入门教程实例3 英文教程 Learning Vue 1.0: Step By Step vue Learning Tutorials 社区 sf - vue标签 知乎 - vue标签 Vue.js专业中文社区 vue - issues 视频教程 小凡哥录制视频教程 二. 文档 API Vue.js - API router vue-router文档 表格 ZEE大神作品 - vue-editable 分页 vue入门－实现一个分页组件(1.0.3版本) vue(1.0.3) 分页组件 分页组件 – 命令方式，支持多个，主要靠配置 移动 Hammer.js wrapper for Vue.js vue的tap手势插件 微信 为微信Web服务量身设计 日历 ZEE大神作品 - vue-calendar Awe - 日历组件 jas0ncn - 日历组件 进度条 vue 进度条 验证 Validator component for VueJS form validator for vue 0.11 Lazyload 图片的lazyload 下拉加载 Loader 【vue】vue组件化开发初体验-示例vue-loader-example学习记录 Uploader vue-file-upload vue-file-upload-component Slide vue-onlySlider-x Drag vue-drag-and-drop 二维码 vue-qrcode 省市联动 Vue 省市区三级联动组件 TimeLine Vue企业级时间轴选择器 Template vue2.0模板 vue2.0全家桶实例 四. 示例 综合示例 官方例子 - 包括Markdown编辑器，表格组件等 Vue, vue-router, Webpack 和 vue-loader 简单的vuejs例子 - 群内高手X-Roy大作 vue single page app example 使用node+vue.js实现SPA应用 Ajax A Vue.js component for creating simple AJAX forms. Webpack Vue + webpack 项目实践 基于vue.js和webpack的Chat示例 Vue.js 和 Webpack（一） Vue.js 和 Webpack（二） Vue.js 和 Webpack（三） 二哲 - 结合具体项目的webpack配置 Gulp vue-gulp-webpack单页面组件开发 Tab vue tab Shopping 基于Vue模仿蘑菇街的单页应用 其它 Ant Design 的 Vue 实现 基于vue.js重写Cnodejs.org社区的webapp 北京-giscafer - vue+webpack+node.js 价格监测应用 五. 开发工具相关 Atom atom vue 代码高亮 如何发布一个Atom的package vue-format Sublime-text Vue Syntax Highlight Webstorm webstorm添加*.vue文件支持 webstorm vue插件 六. 答疑 Vue.js为什么不支持templateUrl模式 实现了vuejs组件之间的通讯问题 国内有哪些公司在用Vue.js，有什么心得 vue 支持服务器端渲染吗 Vue.js 和 Webpack 七. 源码学习 Vue.js 源码学习笔记 VUE 源码分析 vue源码分析之如何实现observer和watcher vue源码解析之一：transition Vue源码学习 Vue.js v1.0.18 八. 框架相关 尤小右 - 4-1 Vue.js-数据驱动的组件化前端开… Evan You - Diving Deep into Vue.js 文章转自：https://github.com/jsfront/src/blob/master/vuejs.md","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://shenjoel.github.io/tags/vue/"}],"keywords":[]},{"title":"初识OneSignal","slug":"初识onesignal","date":"2016-12-19T11:28:33.000Z","updated":"2023-02-02T10:44:18.658Z","comments":true,"path":"2016/12/19/初识onesignal/","link":"","permalink":"http://shenjoel.github.io/2016/12/19/%E5%88%9D%E8%AF%86onesignal/","excerpt":"","text":"对于web site的意义相信大家对于我们的手机锁屏界面上推送的消息都不陌生，尽管拿不到确切的数据证明用户的点击转化率有多高，但多一种通知的渠道，便能配合各种运营营销计划。但是，国内的大部分情况，消息推送的来源就是应用程序。对于web site来说，浏览过就是过了，即使对你的站点有那么一丝丝兴趣，当前无用，关了也就关了。俗话说得好，“不在沉默中爆发，便在沉默中灭亡”，那么就让OneSignal来爆发吧。 什么是OneSignal?OneSignal 就是针对网站和移动应用程序的推送通知服务，为每个平台提供专用的SDK，RESTful服务器API和在线的运营后台，供营销人员设计和发送推送通知。 为什么要使用OneSignal?– 使用简易：实现到GCM / FCM（Google）和APNS（Apple）协议的可靠接口是很困难的。 有开源项目做到这一点，但即使最好的一个突破，当消息量一次超过50万。 这些协议也经常变化，例如，苹果最近发布了一个新的通知协议，并弃用他们旧的。– 高级功能：OneSignal提供营销工具，包括A / B测试，细分定位，本地化，点滴营销和转化跟踪。– 多平台支持：OneSignal提供统一的UI和API，以在iOS，Android，Amazon Fire，Windows Phone，Chrome应用，Safari，Chrome Web和Firefox上推送通知。– 支持SDK：OneSignal为几乎所有主要的跨平台移动开发环境提供SDK，包括Unity，PhoneGap，Cordova，Ionic，Intel XDK，React Native，Corona，Xamarin，Marmalade和Adobe Air。– 免费开源：最重要的是，OneSignal是一个免费服务，不限设备和通知。 参考文档:https://documentation.onesignal.com/docs","categories":[],"tags":[{"name":"OneSignal","slug":"OneSignal","permalink":"http://shenjoel.github.io/tags/OneSignal/"},{"name":"webpush","slug":"webpush","permalink":"http://shenjoel.github.io/tags/webpush/"}],"keywords":[]},{"title":"javascript中0.1 + 0.2 != 0.3?","slug":"javascript中0-1-0-2-0-3","date":"2016-11-20T11:32:55.000Z","updated":"2023-02-01T13:52:57.332Z","comments":true,"path":"2016/11/20/javascript中0-1-0-2-0-3/","link":"","permalink":"http://shenjoel.github.io/2016/11/20/javascript%E4%B8%AD0-1-0-2-0-3/","excerpt":"","text":"0.1+0.2 等于0.3吗？相信拿着这条题目随便问一个高年级的小学生，他们都会毫不犹豫都回答：相等。是的，相等是正常的，这是常识。但是都说实践是检验真理的唯一标准，拿这道简单的算术题用javascript在chrome控制台试验一下： 结果令人大跌眼镜，在控制台输入0.1+0.2 == 0.3返回的结果竟然是false我们输入0.1+0.2，看看结果，竟然是0.30000000000000004。 这是为什么呢？在《Javascript权威指南》中有提到，JS是不区分整数和浮点数的，JS采用的是IEEE 754标准定义的64位浮点格式表示数字，所以JS中的所有数字都是浮点数。按照JS的数字格式，整数有的范围是-2^53 ~ 2^53，而且只能表示有限个浮点数，能表示的个数为2^64 − 2^53 + 3个。至于为什么是这个范围，可以具体看看《JavaScript 中的数字》这篇文章也解下。而我们都知道，浮点数的个数是无限的，这就导致了JS不能精确表达所有的浮点数，而只能是一个近似值。 那怎样才能比较0.1+0.2 == 0.3呢？既然浮点数是一个近似值，那我们可以认定在某个可以接受的精度范围内，他们是相等的。因此可以定义一个比较函数来比较浮点数。1234function isFloatEqual(f1,f2,digits) &#123; return f1.toFixed(digits) === f2.toFixed(digits);&#125; isFloatEqual(0.1+0.2,0.3,10); // 返回true 可以看到，这时再比较0.1+0.2就与0.3相等了。这种比较，其实是字符串的比较，toFixed方法，返回的是一个字符串。可以在控制台中输入：10.1.toFixed(1)+0.2.toFixed(1)你会发现，返回的结果是”0.10.2” 这种方法解决了0.1+0.2==0.3的问题，但是当我用isFloatEqual(0.3 - 0.2,0.1,10)的时候，发觉返回的值是false，这又是为什么呢？ 原来0.3 - 0.2计算出来的是0.09999999999999998，上面的方法只能覆盖到计算结果比实际结果大的情况，而对于小的情况无能为力。 我们知道，当两个数相减，如果差在约定的精度范围内，我们就可以认为这两个数相等，根据这个原理，再来重写isFloatEqual函数，如下：12345function isFloatEqual(f1,f2,digits) &#123; return Math.abs(f1 - f2) &lt; digits;&#125; isFloatEqual(0.1+0.2,0.3,0.001); // trueisFloatEqual(0.3-0.2,0.1,0.001); // true 那除了上面的方法外，能不能让JS在做加减法的时候精确一点呢？我们知道，只要在-2^53 ~ 2^53的范围内，JS做整数的加减运算是精确的，那么我们是不是可以将浮点数转换为整数，再进行运算呢？按照这个思路，在《浅谈JavaScript浮点数及其运算》这篇文章中，提供了一种方法，将代码粘贴如下：1234567function accAdd(arg1,arg2)&#123; var r1,r2,m; try&#123;r1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)) return (arg1*m+arg2*m)/m&#125; 这种方法是先计算出两个浮点数的小数位数n,两个参数再分别与10^n（放大倍数）相乘，以达到对两个参数取整的目的，再用整数来进行相加运算，加完后除掉放大的倍数就可以得出结果了。 现在用accAdd(0.1,0.2)，返回的结果是0.3了，但是评论里面马上有人提出accAdd(2.22,0.1) 的结果不是2.32，而是2.3200000000000003。原来在做arg1*m这一步时，依旧是浮点数运算，所以返回的结果不一定是整数，依旧是浮点数。 我看到作者在做减法的时候用了toFixed()，如果用toFixed(n)是不是就可以了呢？来试一下，函数改造成这样：12345678function accAdd(arg1,arg2)&#123; var r1,r2,n,m; try&#123;r1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r2=0&#125; n = Math.max(r1,r2); m=Math.pow(10,n); return ((arg1*m+arg2*m)/m).toFixed(n)&#125;这次再调用accAdd(2.22,0.1)时，返回的是2.32了，完美！ 但是手贱试了下accAdd(2.22,0.08),返回的结果是2.30，而我期望返回的结果是2.3。上文已经提到过，toFixed返回的是一个字符串，所以用toFixed返回2.30看来是正常的了。那如果要返回2.3要怎样做呢？ 其实很简单，用parseInt将arg1*m转换为整数就可以了。1234567function accAdd(arg1,arg2)&#123; var r1,r2,m; try&#123;r1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)) return (parseInt(arg1*m,10)+parseInt(arg2*m,10))/m&#125;然并卵，这个计算依然是不准确的，有空再想想。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://shenjoel.github.io/tags/javascript/"}],"keywords":[]},{"title":"总结使用node对接OAuth2的一些经验","slug":"总结使用node对接OAuth2的一些经验","date":"2016-10-08T08:52:06.000Z","updated":"2023-02-01T13:52:57.332Z","comments":true,"path":"2016/10/08/总结使用node对接OAuth2的一些经验/","link":"","permalink":"http://shenjoel.github.io/2016/10/08/%E6%80%BB%E7%BB%93%E4%BD%BF%E7%94%A8node%E5%AF%B9%E6%8E%A5OAuth2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"1、在服务器端的客户端证书验证，DEPTH_ZERO_SELF_SIGNED_CERT错误request模块中，rejectUnauthorized参数可设置忽略验证，开发调试方便，但生产环境下不可使用，正确方式是带上agentOptions: {ca: “xxx.pem”, …}参考stackoverflow 2、发掘了两个不错的模块 memory-cache– A simple in-memory cache. put(), get() and del()– 简单好用 shortid– ShortId creates amazingly short non-sequential url-friendly unique ids. Perfect for url shorteners, MongoDB and Redis ids, and any other id users might see.– 功能强大","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://shenjoel.github.io/tags/node/"},{"name":"OAuth2","slug":"OAuth2","permalink":"http://shenjoel.github.io/tags/OAuth2/"}],"keywords":[]},{"title":"Error: DEPTH_ZERO_SELF_SIGNED_CERT","slug":"Error-DEPTH-ZERO-SELF-SIGNED-CERT","date":"2016-09-20T03:16:31.000Z","updated":"2023-02-01T13:52:57.331Z","comments":true,"path":"2016/09/20/Error-DEPTH-ZERO-SELF-SIGNED-CERT/","link":"","permalink":"http://shenjoel.github.io/2016/09/20/Error-DEPTH-ZERO-SELF-SIGNED-CERT/","excerpt":"","text":"在实现第三方系统对接时，提示了一个错误：Error: DEPTH_ZERO_SELF_SIGNED_CERT 而在开发过程中跳过这一问题的方法是添加下面这句：process.env.NODE_TLS_REJECT_UNAUTHORIZED = &quot;0&quot;; 下文是一个中肯的解释：Node is complaining because the TLS (SSL) certificate it’s been given is self-signed (i.e. it has no parent - a depth of 0). It expects to find a certificate signed by another certificate that is installed in your OS as a trusted root. Your “fix” is to disable Node from rejecting self-signed certificates by allowing ANY unauthorised certificate. Your fix is insecure and shouldn’t really be done at all, but is often done in development (it should never be done in production). The proper solution should be to put the self-signed certificate in your trusted root store OR to get a proper certificate signed by an existing Certificate Authority (which is already trusted by your server). 大概意思是：Node被赋予了TLS（SSL）证书是自签名的，它希望找到由安装在您的操作系统作为一个受信任的根证书，另一个签名的证书。 你的“修复”是允许任何未经授权的证书，取消其拒绝自签名证书节点。这里指 process.env.NODE_TLS_REJECT_UNAUTHORIZED = “0”; 你的解决方法是不安全的，应该不是真的都做到，但往往是在做开发（它不应该在生产中进行）。 正确的解决办法应该是把自签名证书在受信任的根存储或度日（这已经是你的服务器信任）现有的证书颁发机构签署一个适当的证书。 此文章以记录自己还在坑里努力往上爬","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://shenjoel.github.io/tags/node/"}],"keywords":[]},{"title":"探索pjax","slug":"探索pjax","date":"2016-08-31T10:23:18.000Z","updated":"2023-02-01T13:52:57.332Z","comments":true,"path":"2016/08/31/探索pjax/","link":"","permalink":"http://shenjoel.github.io/2016/08/31/%E6%8E%A2%E7%B4%A2pjax/","excerpt":"","text":"什么是pjax? 它是一种浏览方式，当你点击一个站内的链接的时候， 不是做页面跳转， 而是站内页面刷新。 它彻底改变标准网站的用户体验，多页面的呈现，单页面的操作 为什么要用pjax？web研发模式演变的两种状态： 以后端为主的MVC开发模式– 前后端耦合程度高，后端控制MV层，沟通成本大，但利于SEO Ajax为主的SPA型开发模式– SPA - Single Page Application 指单页面应用，通过带”#”的链接，获取其hash值在同一个页面更新不同的场景，达到浏览器级别的前进与后退；而这种开发模式，前后端是通过ajax交换数据，所以爬虫爬下来的页面都是空白，虽然拥有良好的用户体验，但不利于SEO 有没有那么一种解决方案，即能做SEO，又能得到像SPA一样的用户体验呢？ 是的，pjax是一个优秀的解决方案，你有足够多的理由来使用它： 可以在页面切换间平滑过渡，增加Loading动画。 可以在各个页面间传递数据，不依赖URL。 可以选择性的保留状态，如音乐网站，切换页面时不会停止播放歌曲。 所有的标签都可以用来跳转，不仅仅是a标签。 避免了公共JS的反复执行，如无需在各个页面打开时都判断是否登录过等等。 减少了请求体积，节省流量，加快页面响应速度。 平滑降级到低版本浏览器上，对SEO也不会有影响。 pjax的原理第一步：拦截a标签的默认跳转动作。第二步：使用Ajax请求新页面。第三步：将返回的Html替换到页面中。第四步：使用HTML5的History API或者Url的Hash修改Url。 HTML5 History APIhistory.pushState(state, title, url)pushState方法会将当前的url添加到历史记录中，然后修改当前url为新url。请注意，这个方法只会修改地址栏的Url显示，但并不会发出任何请求。我们正是基于此特性来实现Pjax。它有3个参数： state: 用以存储关于你所要插入到历史记录的条目的相关信息。 title: 顾名思义，就是document.title。不过这个参数目前并无作用，浏览器目前会选择忽略它。 url: 新url，也就是你要显示在地址栏上的url。 history.replaceState(state, title, url)replaceState方法与pushState大同小异，区别只在于pushState会将当前url添加到历史记录，之后再修改url，而replaceState只是修改url，不添加历史记录。 window.onpopstate 事件一般来说，每当url变动时，popstate事件都会被触发。但若是调用pushState来修改url，该事件则不会触发，因此，我们可以把它用作浏览器的前进后退事件。该事件有一个参数，就是上文pushState方法的第一个参数state。 不支持HTML5 PushState的浏览器怎么办？IE6到IE9是不支持pushState的，要修改Url，只能利用Url的Hash，也即是#号。 你可以随意找个网站试一下，在url后面加上#号和任意内容，页面并不会刷新。此时点击后退也只会回到上一条#号，同样不会刷新。 那么我们只需把pushState(新url)换成location.hash = 新url，把onpopstate事件换成onhashchange事件就可以兼容IE了。QQ音乐，网易云音乐等就是使用这种方式。","categories":[],"tags":[{"name":"pjax","slug":"pjax","permalink":"http://shenjoel.github.io/tags/pjax/"}],"keywords":[]},{"title":"ES6学习笔记-尾递归优化","slug":"ES6学习笔记-尾递归优化","date":"2016-08-26T08:12:18.000Z","updated":"2023-02-01T13:52:57.330Z","comments":true,"path":"2016/08/26/ES6学习笔记-尾递归优化/","link":"","permalink":"http://shenjoel.github.io/2016/08/26/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/","excerpt":"","text":"尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。12345function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性 如果是非尾递归的fibonacci 递归方法12345678function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10); // 89// Fibonacci(100)// Fibonacci(500)// 堆栈溢出了如果我们使用尾递归优化过的fibonacci 递归算法 1234567function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。12345678function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5) // 120上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。1234567891011function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。 第二种方法就简单多了，就是采用ES6的函数默认值。12345function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 严格模式ES6的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。123456function restricted() &#123; &quot;use strict&quot;; restricted.caller; // 报错 restricted.arguments; // 报错&#125;restricted(); 尾递归优化的实现尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。123456789function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…)上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归100000次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125;上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。1234567function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。12trampoline(sum(1, 100000))// 100001蹦床函数并不是真正的尾递归优化，下面的实现才是。1234567891011121314151617181920212223242526function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://shenjoel.github.io/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://shenjoel.github.io/tags/javascript/"},{"name":"优化","slug":"优化","permalink":"http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"}],"keywords":[]},{"title":"ES6学习笔记-尾调用优化","slug":"ES6学习笔记-尾调用优化","date":"2016-08-26T07:24:56.000Z","updated":"2023-02-01T13:52:57.330Z","comments":true,"path":"2016/08/26/ES6学习笔记-尾调用优化/","link":"","permalink":"http://shenjoel.github.io/2016/08/26/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/","excerpt":"","text":"什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。以下三种情况，都不属于尾调用。12345678910111213// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。1234function f(x)&#123; g(x); return undefined;&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125;上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。12345678910111213function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3);上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125;上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://shenjoel.github.io/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://shenjoel.github.io/tags/javascript/"},{"name":"优化","slug":"优化","permalink":"http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"}],"keywords":[]},{"title":"ES6学习笔记-数组的空位","slug":"ES6学习笔记-数组的空位","date":"2016-08-24T09:42:15.000Z","updated":"2023-02-01T13:52:57.330Z","comments":true,"path":"2016/08/24/ES6学习笔记-数组的空位/","link":"","permalink":"http://shenjoel.github.io/2016/08/24/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D/","excerpt":"","text":"数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。1Array(3) // [, , ,]上面代码中，Array(3)返回一个具有3个空位的数组。 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。120 in [undefined, undefined, undefined] // true0 in [, , ,] // false ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314// forEach方法[,&#x27;a&#x27;].forEach((x,i) =&gt; console.log(i)); // 1// filter方法[&#x27;a&#x27;,,&#x27;b&#x27;].filter(x =&gt; true) // [&#x27;a&#x27;,&#x27;b&#x27;]// every方法[,&#x27;a&#x27;].every(x =&gt; x===&#x27;a&#x27;) // true// some方法[,&#x27;a&#x27;].some(x =&gt; x !== &#x27;a&#x27;) // false// map方法[,&#x27;a&#x27;].map(x =&gt; 1) // [,1]// join方法[,&#x27;a&#x27;,undefined,null].join(&#x27;#&#x27;) // &quot;#a##&quot;// toString方法[,&#x27;a&#x27;,undefined,null].toString() // &quot;,a,,&quot; ES6则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。12Array.from([&#x27;a&#x27;,,&#x27;b&#x27;])// [ &quot;a&quot;, undefined, &quot;b&quot; ]扩展运算符（…）也会将空位转为undefined。12[...[&#x27;a&#x27;,,&#x27;b&#x27;]]// [ &quot;a&quot;, undefined, &quot;b&quot; ]copyWithin()会连空位一起拷贝。12[...[&#x27;a&#x27;,,&#x27;b&#x27;]]// [ &quot;a&quot;, undefined, &quot;b&quot; ]fill()会将空位视为正常的数组位置。1new Array(3).fill(&#x27;a&#x27;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]for…of循环也会遍历空位。123456let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1上面代码中，数组arr有两个空位，for…of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。12345678910// entries()[...[,&#x27;a&#x27;].entries()] // [[0,undefined], [1,&quot;a&quot;]]// keys()[...[,&#x27;a&#x27;].keys()] // [0,1]// values()[...[,&#x27;a&#x27;].values()] // [undefined,&quot;a&quot;]// find()[,&#x27;a&#x27;].find(x =&gt; true) // undefined// findIndex()[,&#x27;a&#x27;].findIndex(x =&gt; true) // 0由于空位的处理规则非常不统一，所以建议避免出现空位。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://shenjoel.github.io/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://shenjoel.github.io/tags/javascript/"}],"keywords":[]},{"title":"移动web性能优化篇-图片的加载","slug":"移动web性能优化篇-图片的加载","date":"2016-08-20T09:55:40.000Z","updated":"2023-02-01T13:52:57.332Z","comments":true,"path":"2016/08/20/移动web性能优化篇-图片的加载/","link":"","permalink":"http://shenjoel.github.io/2016/08/20/%E7%A7%BB%E5%8A%A8web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87-%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"控制图片加载在移动浏览器打开网页，经常能感觉到明显的卡顿。造成卡顿的原因除了页面 DOM 结构复杂、CSS 过多地触发 Layout/Paint/Composite、存在复杂 JS 逻辑等等，也可能是没有控制图片的加载时机。 通常浏览器会并发加载 6 个同域名图片，如果做了域名散列，那很可能在打开页面后的短短几秒内，几十个图片都在加载。这些连接带来的 TCP、带宽、CPU、内存等开销，很容易让页面卡顿。所以在移动端，我们要让图片加载变得可控。 按需加载图片。 在 PC 端，我们基本都会做图片 Lazy Load，这个优化策略在移动端同样适用。由于移动端性能有限、带宽昂贵，Lazy Load 更为重要。实际上不光是图片可以做 Lazy Load，页面所有资源包括 DOM 节点都应该做成按需加载。通常在移动端，我们只加载页面可视区域及其下方一定距离内的资源。 顺序加载图片。 在 PC 端，由于硬件性能和带宽足够，并行加载更多的图片通常是最好的选择。而在移动端，人为控制图片加载顺序，例如使其从上到下、从左到右逐个加载，有时可以带来更好的体验。 不要在页面滚定时加载图片。 按需加载图片逻辑需要监听页面滚动事件，根据页面当前可视区域决定加载哪些图片。在移动端滚动页面本来就很耗费性能，如果这时候还要加载图片，非常容易造成页面卡顿。在页面滚定停止之后才开始载入图片，能有效减少这种卡顿。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"移动WEB","slug":"移动WEB","permalink":"http://shenjoel.github.io/tags/%E7%A7%BB%E5%8A%A8WEB/"},{"name":"图片","slug":"图片","permalink":"http://shenjoel.github.io/tags/%E5%9B%BE%E7%89%87/"}],"keywords":[]},{"title":"移动web性能优化篇-图片的大小","slug":"移动web性能优化篇-图片的大小","date":"2016-08-20T09:40:50.000Z","updated":"2023-02-01T13:52:57.333Z","comments":true,"path":"2016/08/20/移动web性能优化篇-图片的大小/","link":"","permalink":"http://shenjoel.github.io/2016/08/20/%E7%A7%BB%E5%8A%A8web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87-%E5%9B%BE%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"控制图片大小图片高宽越大，意味着需要越多的网络开销。常见图片格式都经过了高度压缩，尺寸越大的图片还意味着浏览器在解码过程中需要耗费更多 CPU，解码之后的位图需要占用更多内存。在移动端，我们更应该关注图片大小。 根据 DPR（window.devicePixelRatio，设备像素比）选择合适的图片尺寸。 现在的手机基本上都是高清屏，如果一味追求让图片更小而使用单倍图也不现实。这一点上，最佳实践是根据产品特性，结合用户 DPR 分布情况来选择合适的尺寸。例如在我们某个产品中：图片加载速度比图片质量更重要；用户 DPR 分布前三是：2、3、1.5。我们最终使用了 1.5 倍图，并且在图床缩放图片时，加了一点点锐化效果。最终图片体积很小，质量也尚可接受。 处理好响应式图片（Responsive Image）。 移动上很多图片宽度不是固定像素值，例如通栏 Banner 图片的宽度是跟着设备走的。对于这种场景，使用 JS 获取设备宽度，拼出最适合当前设备的图片尺寸，交给图床进行缩放，无疑能在图片体积和质量上找到最佳平衡点。但这种做法并不可取，移动设备宽度各式各样，如果裁图规格太多，容易降低 CDN 缓存命中率。图床实时处理完图片再分发到 CDN 更耗时，在移动端让图片命中 CDN 缓存也很重要。处理响应式图片的最佳实践是根据用户屏幕尺寸分布，制定出几档裁图规则，页面根据用户设备宽度使用最合适的档位，并对重要的图片（例如头部焦点图）提前预热 CDN。 使用 WEBP 格式。 有一种减少图片体积的灵丹妙药 —— 使用压缩比例更高的 WEBP 格式。《移动端图片格式调研》这篇文章详细地对比了各种移动端图片格式及各自适用场景。对于 WEBP 的最佳实践是只要浏览器支持就用，虽然 WEBP 解码慢于 JPG，但在同等图片质量下，WEBP 体积通常比 JPG 小很多。 要判断浏览器是否支持 WEBP，可以检查 HTTP 请求头部字段 Accept 的值是否包含 webp。例如这是 Chrome 给图片请求加的 Accept： Accept: image/webp,image/,/*;q=0.8","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"移动WEB","slug":"移动WEB","permalink":"http://shenjoel.github.io/tags/%E7%A7%BB%E5%8A%A8WEB/"},{"name":"图片","slug":"图片","permalink":"http://shenjoel.github.io/tags/%E5%9B%BE%E7%89%87/"}],"keywords":[]},{"title":"移动web性能优化篇-图片的影响","slug":"移动web性能优化篇-图片的影响","date":"2016-08-20T08:27:25.000Z","updated":"2023-02-01T13:52:57.333Z","comments":true,"path":"2016/08/20/移动web性能优化篇-图片的影响/","link":"","permalink":"http://shenjoel.github.io/2016/08/20/%E7%A7%BB%E5%8A%A8web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87-%E5%9B%BE%E7%89%87%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"本文主要讨论在移动 WEB 中，图片的加载给页面整体性能带来的影响以及优化策略。 我们知道，浏览器的 DOMContentLoaded 事件会在主页面加载并解析完成之后触发，不会等页面样式、图片、iframe 等子资源加载完。以下是 MDN 对它的描述： The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. 但在实际测试中，移动端完全相同的页面，加载与不加载图片对 DOMContentLoaded 触发时机的影响却很大。以下是我们在某个移动产品中，将图片延迟加载后的 DOMContentLoaded 时间对比，可以看出明显变化： 我们只是将页面所有图片（大约十几张）进行延迟加载，就让 DOMContentLoaded 事件提前 250 毫秒触发。这是我之前没有意料到的，移动设备在网络、CPU、内存等方面的性能与 PC 相比差距很大，很多 PC 上可以忽略的问题，在移动端必须重视起来。 移动 WEB 要做好图片优化，无外乎两点： 控制图片大小 控制图片加载","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://shenjoel.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"移动WEB","slug":"移动WEB","permalink":"http://shenjoel.github.io/tags/%E7%A7%BB%E5%8A%A8WEB/"},{"name":"图片","slug":"图片","permalink":"http://shenjoel.github.io/tags/%E5%9B%BE%E7%89%87/"}],"keywords":[]},{"title":"在hexo中加入多说评论模块","slug":"在hexo中加入多说评论","date":"2016-08-19T07:51:58.000Z","updated":"2023-02-01T13:52:57.332Z","comments":true,"path":"2016/08/19/在hexo中加入多说评论/","link":"","permalink":"http://shenjoel.github.io/2016/08/19/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA/","excerpt":"","text":"首先在根目录下_config.yml中增加duoshuo_shortname: 你站点的short_name，这里的short_name也就是你的二级域名, 例如(http://shenjoel.github.io/)。如果使用的是默认的landscape主题只需要修改themes\\landscape\\layout_partial\\article.ejs中的 1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt; 改为 1234567891011121314151617181920&lt;% if (!index &amp;&amp; page.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div id=&quot;ds-thread&quot; class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= page.path %&gt;&quot; data-title=&quot;&lt;%= page.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&quot;datoublog&quot;&#125;; (function() &#123; var ds = document.createElement(&#x27;script&#x27;); ds.type = &#x27;text/javascript&#x27;;ds.async = true; ds.src = (document.location.protocol == &#x27;https:&#x27; ? &#x27;https:&#x27; : &#x27;http:&#x27;) + &#x27;//static.duoshuo.com/embed.js&#x27;; ds.charset = &#x27;UTF-8&#x27;; (document.getElementsByTagName(&#x27;head&#x27;)[0] || document.getElementsByTagName(&#x27;body&#x27;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt;&lt;/section&gt;&lt;% &#125; %&gt;","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://shenjoel.github.io/tags/hexo/"},{"name":"多说","slug":"多说","permalink":"http://shenjoel.github.io/tags/%E5%A4%9A%E8%AF%B4/"},{"name":"评论","slug":"评论","permalink":"http://shenjoel.github.io/tags/%E8%AF%84%E8%AE%BA/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2016-08-19T07:51:58.000Z","updated":"2023-02-01T13:52:57.331Z","comments":true,"path":"2016/08/19/hello-world/","link":"","permalink":"http://shenjoel.github.io/2016/08/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://shenjoel.github.io/tags/hexo/"}],"keywords":[]}]}